use crate::{
    tokens::{Token, LexicalError},
    ast::{Expression, ExpressionKind, Statement, StatementKind, Location, Operator},
};

grammar<'input>();

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "var" => Token::KeywordVar,
        "print" => Token::KeywordPrint,
        "identifier" => Token::Identifier(<&'input str>),
        "int" => Token::Integer(<i64>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        "=" => Token::Assign,
        ";" => Token::Semicolon,
        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
    }
}

pub Script: Vec<Statement<'input>> = {
    <Statement*>,
}

pub Statement: Statement<'input> = {
    <start: @L> "var" <name:"identifier"> "=" <value:Expression> ";" <end: @R> => Statement { kind: StatementKind::Variable { name, value }, location: Location(start, end) },
    <start: @L> "print" <value:Expression> ";" <end: @R> => Statement { kind: StatementKind::Print { value }, location: Location(start, end) },
    <start: @L> <error: !> ";" <end: @R> => Statement { kind: StatementKind::Error(error), location: Location(start, end) },
}

pub Expression: Box<Expression<'input>> = {
    #[precedence(level="1")]
    Term,

    #[precedence(level="2")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> <operator: MulDiv> <rhs: Expression> <end: @R> => Box::new(Expression { kind: ExpressionKind::BinaryOperation { lhs, operator, rhs }, location: Location(start, end) }),

    #[precedence(level="3")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> <operator: AddSub> <rhs: Expression> <end: @R> => Box::new(Expression { kind: ExpressionKind::BinaryOperation { lhs, operator, rhs }, location: Location(start, end) }),

    <start: @L> <error: !> <end: @L> => Box::new(Expression { kind: ExpressionKind::Error(error), location: Location(start, end) }),
}

MulDiv: Operator = {
    "*" => Operator::Mul,
    "/" => Operator::Div,
};

AddSub: Operator = {
    "+" => Operator::Add,
    "-" => Operator::Sub,
};

pub Term: Box<Expression<'input>> = {
    <start: @L> <i: "int"> <end: @R> => Box::new(Expression { kind: ExpressionKind::Integer(i), location: Location(start, end) }),
    <start: @L> <ident: "identifier"> <end: @R> => Box::new(Expression { kind: ExpressionKind::Variable(ident), location: Location(start, end) }),
    "(" <Expression> ")"
}