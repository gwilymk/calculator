use crate::{
    tokens::{Token, LexicalError},
    ast::{Expression, ExpressionKind, Statement, StatementKind, Location, Operator},
};

grammar<'input>();

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "var" => Token::KeywordVar,
        "print" => Token::KeywordPrint,
        "identifier" => Token::Identifier(<&'input str>),
        "int" => Token::Integer(<i64>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        "=" => Token::Assign,
        ";" => Token::Semicolon,
        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
    }
}

pub Script: Vec<Statement<'input>> = {
    <Statement*>,
}

WithLoc<Rule, Output>: Output = <start: @L> <rule: Rule> <end: @R> => rule.with_loc(Location(start, end));

Statement: Statement<'input> = WithLoc<StatementKind, Statement>;

StatementKind: StatementKind<'input> = {
    "var" <name:"identifier"> "=" <value:Expression> ";" => StatementKind::Variable { <> },
    "print" <value:Expression> ";" => StatementKind::Print { <> },
    <error: !> ";" => StatementKind::Error(<>),
}


Expression: Box<Expression<'input>> = {
    #[precedence(level="1")]
    "(" <Expression> ")",
    <start: @L> <term: Term> <end: @R> => term.with_loc(Location(start, end)),

    #[precedence(level="2")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> <operator: MulDiv> <rhs: Expression> <end: @R> => ExpressionKind::BinaryOperation { lhs, operator, rhs }.with_loc(Location(start, end)),

    #[precedence(level="3")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> <operator: AddSub> <rhs: Expression> <end: @R> => ExpressionKind::BinaryOperation { lhs, operator, rhs }.with_loc(Location(start, end)),

    <start: @L> <error: !> <end: @R> => ExpressionKind::Error(error).with_loc(Location(start, end)),
}

MulDiv: Operator = {
    "*" => Operator::Mul,
    "/" => Operator::Div,
};

AddSub: Operator = {
    "+" => Operator::Add,
    "-" => Operator::Sub,
};

Term: ExpressionKind<'input> = {
    <"int"> => ExpressionKind::Integer(<>),
    <"identifier"> => ExpressionKind::Variable(<>),
}