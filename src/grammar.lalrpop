use crate::{
    tokens::{Token, LexicalError},
    ast,
};

use lalrpop_util::ErrorRecovery;

grammar<'err, 'input>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, LexicalError>>);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "var" => Token::KeywordVar,
        "print" => Token::KeywordPrint,
        "identifier" => Token::Identifier(<&'input str>),
        "int" => Token::Integer(<i64>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        "=" => Token::Assign,
        ";" => Token::Semicolon,
        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
    }
}

pub Script: Vec<ast::Statement<'input>> = {
    <Statement*>,
}

pub Statement: ast::Statement<'input> = {
    "var" <name:"identifier"> "=" <value:Expression> ";" => ast::Statement::Variable { <> },
    "print" <value:Expression> ";" => ast::Statement::Print { <> },
    <!> ";" => { errors.push(<>); ast::Statement::Error },
}

pub Expression: Box<ast::Expression<'input>> = {
    #[precedence(level="1")]
    Term,

    #[precedence(level="2")]
    #[assoc(side="left")]
    <lhs:Expression> <operator:MulDiv> <rhs:Expression> => Box::new(ast::Expression::BinaryOperation { <> }),

    #[precedence(level="3")]
    #[assoc(side="left")]
    <lhs:Expression> <operator:AddSub> <rhs:Expression> => Box::new(ast::Expression::BinaryOperation { <> }),

    <!> => { errors.push(<>); Box::new(ast::Expression::Error) },
}

MulDiv: ast::Operator = {
    "*" => ast::Operator::Mul,
    "/" => ast::Operator::Div,
};

AddSub: ast::Operator = {
    "+" => ast::Operator::Add,
    "-" => ast::Operator::Sub,
};

pub Term: Box<ast::Expression<'input>> = {
    "int" => Box::new(ast::Expression::Integer(<>)),
    "identifier" => Box::new(ast::Expression::Variable(<>)),
    "(" <Expression> ")"
}